#' Analyse raw ion count data
#'
#' \code{stat_Xt} function for propagation of uncertainty for single ions
#' \code{stat_R} function for propagation of uncertainty for isotope ratios (R)
#'
#' Ion count data consisting of time-incremented integer values are process. These functions
#' are currently only supported for data generated by a NanoSIMS50L. Raw ion
#' count data and accompayning is extracted and collated into a single tible
#' from text files with the extensions \emph{.is_txt} and \emph{.stat},
#' respectively. These files can be found in the directories associated with the
#' SIMS measurements.
#'
#' @param df A tibble containing processed ion count data
#' @param Xt A variable constituting the ion count rate
#' @param N A variable constituting the ion counts
#' @param ... Variables for grouping
#' @param ID A character string that uniqually identifies ion pairs for
#' calculating isotope ratios
#' @param ion1 A character string constituting the heavy isotope ("13C")
#' @param ion2 A character string constituting the light isotope ("12C")
#'
#' @return A tibble containing raw ion count data and metadata
#'
#' @examples
#' # Use system.file() to access the examples bundled with this package in the
#' # inst/extdata directory. The examples directories are named:
#' # 2020-01-17-TREASURE and "2018-01-19-GLENDON"
#'
#' # raw data containing 13C and 12C counts on carbonate
#' tb.rw <- read_IC(system.file("extdata", "2018-01-19-GLENDON", package = "point"))
#'
#' # processing raw ion count data
#' tb.pr <- cor_IC(tb.rw, N.rw, t.rw, det_type.mt, deadtime = 44)
#'
#' # single ion descriptive an predictive statistics for all measured ions
#' tb.Xt <- stat_Xt(tb.pr, Xt.pr, N.pr, file.nm, species.nm)
#'
#' # descriptive an predictive statistics for 13C/12C ratios
#' tb.R <- stat_R(tb.pr, Xt.pr, N.pr, ID = "ID", ion1 = "13C", ion2 = "12C",
#' file.nm, species.nm)
#'
#' @export
stat_Xt <- function(df, Xt, N, ...){

  Xt <- enquo(Xt)
  N <- enquo(N)
  gr_by <- enquos(...)

  args <- list(# number of ion counts
    quo(n()),
    # sum of ion counts (important for external rep)
    quo(sum(!! N)),
    # mean ion count rate
    quo(mean(!! Xt)),
    # standard deviation (SD) count rate
    quo(sd(!! Xt)),
    # relative standard deviation (RSD) count rate
    quo(sd(!! Xt) / mean(!! Xt)),
    # standard error of the mean (SE) count rate
    quo(sd(!! Xt) / sqrt(n())),
    # predicted SD count rate
    quo(sqrt(sum(!!N))),
    # predicted SE count rate
    quo(sqrt(sum(!!N) / n())))

  ls.names <-paste0(c("n_", "Ntot_", "M_", "S_", "RS_", "SeM_", "hat_S_", "hat_SeM_"),
                    quo_name(Xt))

  args <- purrr::set_names(args, nm = ls.names)

  df <- df %>%
    group_by(!!! gr_by) %>%
    summarise(!!! args) %>%
    ungroup()
  }


#' function for propagation of uncertainty in ion ratios (isotope values)
#' @export
stat_R <- function(df, Xt, N, ID, ion1, ion2, ... , latex = FALSE){

  Xt <- enquo(Xt)
  N <- enquo(N)
  gr_by <- enquos(...)

  # # check and remove zero counts
  df <- zeroCt(df = df, N = !!N, ion1 = ion1, ion2 = ion2, !!! gr_by)

  # heavy isotope
  Xt1 <- quo_updt(Xt, ion1)
  M.Xt1 <- quo_updt(Xt, ion1, "M")
  S.Xt1 <- quo_updt(Xt, ion1, "S")

  # light isotope
  Xt2 <- quo_updt(Xt, ion2)
  M.Xt2 <- quo_updt(Xt, ion2, "M")
  S.Xt2 <- quo_updt(Xt, ion2, "S")

  # heavy raw counts
  Yt1 <- quo_updt(N, ion1)
  # light raw counts
  Yt2 <- quo_updt(N, ion2)

  args <- list(
    # number of isotope
    quo(n()),
    # mean isotope
    quo(mean(!!Xt1) / mean(!!Xt2)),
    # correlation coefficient
    quo(cor(!!Xt2, !!Xt1, method = "pearson")),
    # SD isotope
    quo(sqrt(
      ((unique(!!S.Xt1) / unique(!!M.Xt1)) ^ 2) +
        ((unique(!!S.Xt2) / unique(!!M.Xt2)) ^ 2) -
        ((2 * !!quo_updt(my_q = Xt , x = "cor_R") *
            unique(!!S.Xt1)  *
            unique(!!S.Xt2)) /
           (unique(!!M.Xt1) * unique(!!M.Xt2)))) *
        !!quo_updt(my_q = Xt , x = "M_R")),
    # RSD isotope
    quo(!!quo_updt(my_q = Xt , x = "S_R") /
          !!quo_updt(my_q = Xt , x = "M_R") * 1000),
    # SE isotope
    quo(!!quo_updt(my_q = Xt , x = "S_R") / sqrt(n())),
    # RSE isotope
    quo(!!quo_updt(my_q = Xt , x = "SeM_R") /
          !!quo_updt(my_q = Xt , x = "M_R") * 1000),
    # predictive SD isotope
    quo(sqrt((1 / sum(!!Yt2)) +
               (1 / sum(!!Yt1))) *
          unique(!!quo_updt(my_q = Xt , x = "M_R")) *
          sqrt(n())),
    # predictive RSD isotope
    quo(!!quo_updt(my_q = Xt , x = "hat_S_R") /
          !!quo_updt(my_q = Xt , x = "M_R") * 1000),
    # predictive SE isotope
    quo(!!quo_updt(my_q = Xt , x = "hat_S_R") /
          sqrt(n())),
    # predictive RSE isotope
    quo(!!quo_updt(my_q = Xt , x = "hat_SeM_R") /
          !!quo_updt(my_q = Xt , x = "M_R") * 1000),
    # reduced chi squared
    quo((!!quo_updt(my_q = Xt , x = "SeM_R") /
           !!quo_updt(my_q = Xt , x = "hat_SeM_R")) ^ 2)
  )

  ls.names <-paste(c("n", "M", "cor", "S", "RS", "SeM", "RSeM",
                     "hat_S", "hat_RS", "hat_SeM", "hat_RSeM",
                     "chi2"), "R", quo_name(Xt), sep = "_")

  ls.latex <- ls.names %>%
                purrr::set_names(., nm = c("$$n$$", "$$\\bar{x}$$", "$$r$$", "$$s_x$$",
                                           "$$\\epsilon_x$$", "$$s_\\bar{x}$$", "$$\\epsilon_\\bar{x}$$",
                                           "$$\\hat{s}_x$$", "$$\\hat{\\epsilon}_x$$", "$$\\hat{s}_\\bar{x}$$",
                                           "$$\\hat{\\epsilon}_\\bar{x}$$", "$$\\chi^2$$"))

  args <- purrr::set_names(args, nm = ls.names)

  if (latex) {return(list(

  df %>%
    filter(species.nm == ion1 | species.nm == ion2) %>%
    stat_Xt(., Xt = !!Xt, N = !!N, !!! gr_by) %>%
    left_join(df, . ,by = sapply(gr_by, as_name)) %>%
    cov_R(df = . , ID = ID, ion1 = ion1, ion2 = ion2, !!! gr_by) %>%
    group_by(!!! gr_by) %>%
    summarise(!!! args) %>%
    mutate(species.nm = paste(ion1, ion2, sep = "/")) %>%
    rename(R.nm = "species.nm") %>%
    ungroup(),

    ls.latex))}
}



#' function to detect and remove zero counts of desired isotope system
zeroCt <- function(df, N, ion1, ion2, ...){

  N <- enquo(N)
  gr_by <- enquos(...)

  gr.ls <- df %>%
             filter(species.nm == ion1 | species.nm == ion2)

  if (any(gr.ls %>% select(!!N) %>% pull(!!N) == 0)) {

    warning("zero counts present and removed")

  }

  gr.ls <- gr.ls %>%
              filter(!!N == 0) %>%
              select(!!!gr_by)

  df <- anti_join(df, gr.ls, by = sapply(gr_by, as_name))

}

#' covariate convertion for isotope systems
cov_R <- function(df, ID, ion1, ion2, ...){


  gr_by <- enquos(...)

  # filtering single ion stats minor isotope
  df.13C <- df %>% filter(species.nm == ion1)

  # filtering single ion stats major isotope
  df.12C <- df %>% filter(species.nm == ion2) %>% select(-c(!!! gr_by))

  df.R <- full_join(df.13C,  df.12C, by = ID,
                    suffix = c(paste0(".", ion1),
                               paste0(".", ion2)))}

#' quosure updater
quo_updt <- function(my_q, txt = NULL, x = NULL, sepfun = "_"){
  # get expressions
  old_expr <- get_expr(my_q)
  # modify expression, turn expr in to character string
  if (length(txt) == 0){

     new_chr <-paste(x, expr_text(old_expr), sep = sepfun)

     }else{

       if (length(x) == 0){

          new_chr <- paste(expr_text(old_expr),txt, sep = ".")

          }else{
          new_chr <- paste(paste(x, expr_text(old_expr), sep = sepfun), txt, sep = ".")
               }
           }
  # new expression from character
  new_expr <- parse_expr(new_chr)
  # update old quosure
  set_expr(my_q, new_expr)
}
