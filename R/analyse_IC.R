#' Analyse raw ion count data
#'
#' \code{stat_Xt} function for propagation of uncertainty for single ions
#' \code{stat_R} function for propagation of uncertainty for isotope ratios (R)
#'
#' Ion count data consisting of time-incremented integer values are process.
#' These functions are currently only supported for data generated by a
#' NanoSIMS50L. Raw ion count data and accompayning is extracted and collated
#' into a single tible from text files with the extensions \emph{.is_txt} and
#' \emph{.stat}, respectively. These files can be found in the directories
#' associated with the SIMS measurements.
#'
#' @param df A tibble containing processed ion count data
#' @param Xt A variable constituting the ion count rate
#' @param N A variable constituting the ion counts
#' @param species A variable constituting the species analysed
#' @param ... Variables for grouping
#' @param ion1 A character string constituting the heavy isotope ("13C")
#' @param ion2 A character string constituting the light isotope ("12C")
#' @param output A character string for output as summary statistics ("sum");
#' statistics only ("stat"); and statistics with the original data ("complete")
#'
#' @return A tibble containing descriptive and predictive statistics for ion
#' count and isotope ratio data
#'
#' @examples
#' # Use system.file() to access the examples bundled with this package in the
#' # inst/extdata directory. The examples directories are named:
#' # 2020-01-17-TREASURE and "2018-01-19-GLENDON"
#'
#' # raw data containing 13C and 12C counts on carbonate
#' tb.rw <- read_IC(point_example("2018-01-19-GLENDON"))
#'
#' # processing raw ion count data
#' tb.pr <- cor_IC(tb.rw, N.rw, t.rw, det_type.mt)
#'
#' # single ion descriptive an predictive statistics for all measured ions
#' tb.Xt <- stat_Xt(tb.pr, Xt.pr, N.pr, file.nm, species.nm)
#'
#' # descriptive an predictive statistics for 13C/12C ratios
#' tb.R <- stat_R(tb.pr, Xt.pr, N.pr, ID = "ID", ion1 = "13C", ion2 = "12C",
#'                file.nm, species.nm)
#'
#' @export
stat_Xt <- function(df, Xt, N, species, ... , latex = FALSE, output = "sum"){

  Xt <- enquo(Xt)
  N <- enquo(N)
  gr_by <- enquos(..., species)

  args <- list(# number of ion counts
    quo(n()),
    # sum of ion counts (important for external rep)
    quo(sum(!! N)),
    # mean ion count rate
    quo(mean(!! Xt)),
    # standard deviation (SD) count rate
    quo(sd(!! Xt)),
    # standard error of the mean (SE) count rate
    quo(sd(!! Xt) / sqrt(n())),
    # predicted SD count rate
    quo(sqrt(sum(!!N))),
    # predicted SE count rate
    quo(sqrt(sum(!!N) / n())))

  ls.names <-paste0(c("n_", "Ntot_", "M_", "S_", "SeM_", "hat_S_", "hat_SeM_"),
                    quo_name(Xt))

  # to render nice latex variable names in Rmarkdown with mathjax and latex
  ls.latex <- ls.names %>%
    purrr::set_names(., nm = c("$n$",
                               "$N_{tot}$",
                               "$\\bar{X}$",
                               "$s_X$",
                               "$s_\\bar{X}$",
                               "$\\hat{s}_N$",
                               "$\\hat{s}_\\bar{N}$"))

  args <- purrr::set_names(args, nm = ls.names)

  #gr_names <- sapply(gr_by, as_name)

  # switch complete dataset, stats or summary stats
  mod_cal <- function(type) {
    switch(type,
           complete = call2( "mutate", quote(.), quote(!!! args)),
           stat = call2( "transmute", quote(.), quote(!!! args)),
           sum = call2("summarize", quote(.), quote(!!! args)),
    )
  }

  #mod_cal <- call2(if_else(complete, "mutate", "summarize"), quote(.), !!!args)

  df <- df %>%
              group_by(!!! gr_by) %>%
              eval_tidy(expr = mod_cal(output), data = .) %>%
              #summarise(!!! args) %>%
              ungroup()

  # if (summary) {
  #
  # df <- df.sum
  #
  # } else {
  #
  # df <- df.sum %>%
  #        left_join(df, . , by = gr_names)
  #
  # }

  if (latex) {

      df <- df %>%
              mutate(species.nm = purrr::map_chr(species.nm,
                                                 ~latex_parser(.x,
                                                               ion1 = NULL,
                                                               ion2 = NULL))) %>%
              select(file = "file.nm",
                     species = "species.nm",
                     !!! ls.latex)

# return list for nice latex variable names in Rmarkdown with mathjax and latex
    # return(list(df, ls.latex))
    #
    # } else {
    #
  return(df)
  }

  return(df)

  }

#' @describeIn stat_Xt
#'
#' @export
stat_R <- function(df, Xt, N, species, ion1, ion2, ..., latex = FALSE, output = "sum"){

  Xt <- enquo(Xt)
  N <- enquo(N)
  species <- enquo(species)
  gr_by <- enquos(...)

  # heavy isotope
  Xt1 <- quo_updt(Xt, ion1)
  M.Xt1 <- quo_updt(Xt, ion1, "M")
  S.Xt1 <- quo_updt(Xt, ion1, "S")

  # light isotope
  Xt2 <- quo_updt(Xt, ion2)
  M.Xt2 <- quo_updt(Xt, ion2, "M")
  S.Xt2 <- quo_updt(Xt, ion2, "S")

  # heavy raw counts
  Yt1 <- quo_updt(N, ion1)
  # light raw counts
  Yt2 <- quo_updt(N, ion2)

  args <- list(
    # number of isotope
    quo(n()),
    # mean isotope
    quo(mean(!!Xt1) / mean(!!Xt2)),
    # # correlation coefficient
    # quo(cov(!!Xt1, !!Xt2, method = "pearson", use = "everything")),
    # SD isotope
    quo(des_SD_prop(M_R = !!quo_updt(my_q = Xt , x = "M_R"),
                    ion1 = !!Xt1,
                    ion2 = !!Xt2,
                    M_ion1 = !!M.Xt1,
                    M_ion2 = !!M.Xt2,
                    S_ion1 = !!S.Xt1,
                    S_ion2 = !!S.Xt2,
                    n = !!quo_updt(my_q = Xt , x = "n_R"),
                    type = "sd")),
      # quo(sqrt(
      #   ((unique(!!S.Xt1) / unique(!!M.Xt1)) ^ 2) +
      #     ((unique(!!S.Xt2) / unique(!!M.Xt2)) ^ 2) -
      #     (2 *( !!quo_updt(my_q = Xt , x = "cor_R") /
      #        (unique(!!M.Xt1) * unique(!!M.Xt2))))
      #           ) *
      #     !!quo_updt(my_q = Xt , x = "M_R")),
    # quo(sqrt(
    #   ((unique(!!S.Xt1) / unique(!!M.Xt1)) ^ 2) +
    #     ((unique(!!S.Xt2) / unique(!!M.Xt2)) ^ 2) -
    #     ((2 * !!quo_updt(my_q = Xt , x = "cor_R") *
    #         unique(!!S.Xt1)  *
    #         unique(!!S.Xt2)) /
    #        (unique(!!M.Xt1) * unique(!!M.Xt2)))) *
    #     !!quo_updt(my_q = Xt , x = "M_R")),
    # RSD isotope
    quo((!!quo_updt(my_q = Xt , x = "S_R") /
         !!quo_updt(my_q = Xt , x = "M_R")) * 1000),
    # SE isotope
    quo(!!quo_updt(my_q = Xt , x = "S_R") / sqrt(n())),
    # RSE isotope
    quo((!!quo_updt(my_q = Xt , x = "SeM_R") /
         !!quo_updt(my_q = Xt , x = "M_R")) * 1000),
    # predictive SD isotope
    quo(hat_SD_prop(M_R = !!quo_updt(my_q = Xt , x = "M_R"),
                    ion1 = !!Xt1,
                    ion2 = !!Xt2,
                    N_ion1 = !!Yt1,
                    N_ion2 = !!Yt2,
                    n = !!quo_updt(my_q = Xt , x = "n_R"),
                    type = "sd")),
    # quo(sqrt((1 / sum(!!Yt2)) +
    #          (1 / sum(!!Yt1))) *
    #       unique(!!quo_updt(my_q = Xt , x = "M_R")) *
    #       sqrt(n())),
    # predictive RSD isotope
    quo((!!quo_updt(my_q = Xt , x = "hat_S_R") /
         !!quo_updt(my_q = Xt , x = "M_R")) * 1000),
    # predictive SE isotope
    quo(!!quo_updt(my_q = Xt , x = "hat_S_R") / sqrt(n())),
    # quo(sqrt((1 / sum(!!Yt2)) +
    #          (1 / sum(!!Yt1))) *
    #     unique(!!quo_updt(my_q = Xt , x = "M_R"))),
    # predictive RSE isotope
    quo((!!quo_updt(my_q = Xt , x = "hat_SeM_R") /
           !!quo_updt(my_q = Xt , x = "M_R")) * 1000),
    # quo(sqrt((1 / sum(!!Yt2)) +
    #          (1 / sum(!!Yt1))) * 1000),
    # reduced chi squared
    quo((!!quo_updt(my_q = Xt , x = "SeM_R") /
         !!quo_updt(my_q = Xt , x = "hat_SeM_R")) ^ 2)
  )

  ls.names <-paste(c("n", "M", "S", "RS", "SeM", "RSeM",
                     "hat_S", "hat_RS", "hat_SeM", "hat_RSeM",
                     "chi2"), "R", quo_name(Xt), sep = "_")

# to render nice latex variable names in Rmarkdown with mathjax and latex
  ls.latex <- ls.names %>%
                purrr::set_names(., nm = c("$n$",
                                           "$\\bar{R}$",
                                           "$s_{R}$",
                                           "$\\epsilon_{R} \\,$ (\u2030)",
                                           "$s_{\\bar{R}}$",
                                           "$\\epsilon_{\\bar{R}} \\,$ (\u2030)",
                                           "$\\hat{s}_{R}$",
                                           "$\\hat{\\epsilon}_{R} \\,$ (\u2030)",
                                           "$\\hat{s}_{\\bar{R}}$",
                                           "$\\hat{\\epsilon}_{\\bar{R}} \\,$ (\u2030)",
                                           "$\\chi^{2}$"))

  args <- purrr::set_names(args, nm = ls.names)

# extra arg in case of mutate and transmute (isotope ratio for each time step)
  args2 <- append(args, purrr::set_names(list(quo(!!Xt1 / !!Xt2)) ,
                                         nm = paste("R", quo_name(Xt),
                                                    sep = "_")))

# switch complete dataset, stats or summary stats
  mod_cal <- function(type) {
    switch(type,
           complete = call2( "mutate", quote(.), quote(!!! args2)),
           stat = call2( "transmute", quote(.), quote(!!! args2)),
           sum = call2("summarize", quote(.), quote(!!! args)),
           )
  }
  # mod_cal <- call2(if_else(complete, "mutate", "summarize"), quote(.), !!! args2)
  # tb_names <- c(Sample = "sample", File = "file", Species = "species")

  tb_names  <- sapply(gr_by, as_name) %>% purrr::set_names()



  df <- df  %>%
          stat_Xt(., Xt = !!Xt, N = !!N, species =  !!species, !!! gr_by, output = "complete") %>%
# check and remove zero counts
          zeroCt(., N = !!N, species = !!species, ion1 = "13C", ion2 = "12C", !!! gr_by) %>%
          cov_R(df = . , species = !!species, ion1 = ion1, ion2 = ion2, !!! gr_by) %>%
          group_by(!!! gr_by) %>%
          #summarise(!!!args) %>%
          eval_tidy(expr = mod_cal(output), data = .) %>%
          ungroup()


  if (latex) {

# nice variable names in Rmarkdown with webtex and latex
    df <- df %>%
            mutate(R.nm = latex_parser(species = NULL, ion1, ion2)) %>%
            select(!!! tb_names,
                   R = "R.nm",
                   !!! ls.latex)

    return(df)


  } else {

    df <- df %>%
            mutate(R.nm = paste(ion1, ion2, sep = "/"))

    return(df)

  }
}



#' function to detect and remove zero counts of desired isotope system
zeroCt <- function(df, N, species, ion1, ion2, ...){

  N <- enquo(N)
  species <- enquo(species)
  gr_by <- enquos(...)

  gr.ls <- df %>%
            filter(!!species == ion1 | !!species == ion2)

  if (any(gr.ls %>% select(!!N) %>% pull(!!N) == 0)) {

    warning("zero counts present and removed")

  }

  gr.ls <- gr.ls %>%
              filter(!!N == 0) %>%
              select(!!!gr_by)

  df <- anti_join(df, gr.ls, by = sapply(gr_by, as_name))

}

# covariate convertion for isotope systems
cov_R <- function(df, species, ion1, ion2, ...){

  gr_by <- enquos(...)
  species <- enquo(species)

  df <- df %>%
          group_by(!!! gr_by, !! species) %>%
          mutate(ID = row_number()) %>%
          ungroup() %>%
# uniqually identifies ion pairs for calculating isotope ratios (in case raw
# file does not contain it)
          tidyr::unite(col = ID, !!! gr_by, ID, sep = "/", remove = FALSE)


# filtering single ion stats minor isotope
  df.13C <- df %>%
              filter(!! species == ion1)

# filtering single ion stats major isotope
  df.12C <- df %>%
              filter(!! species == ion2) %>%
              select(-c(!!! gr_by))

  df.R <- full_join(df.13C,  df.12C, by = "ID",
                    suffix = c(paste0(".", ion1),
                               paste0(".", ion2)))
  }

#' quosure updater
quo_updt <- function(my_q, txt = NULL, x = NULL, sepfun = "_"){
  # get expressions
  old_expr <- get_expr(my_q)
  # modify expression, turn expr in to character string
  if (length(txt) == 0){

     new_chr <-paste(x, expr_text(old_expr), sep = sepfun)

     }else{

       if (length(x) == 0){

          new_chr <- paste(expr_text(old_expr),txt, sep = ".")

          }else{
          new_chr <- paste(paste(x, expr_text(old_expr), sep = sepfun), txt, sep = ".")
               }
           }
  # new expression from character
  new_expr <- parse_expr(new_chr)
  # update old quosure
  set_expr(my_q, new_expr)
}


latex_parser <- function(species, ion1, ion2){

if(length(species) != 0){

# seperator for poly atomic speices
if (any(str_detect(species, "[:blank:]"))){
  sep <- "--"
} else {
  sep <- ""}

species <- paste(
  paste0(
         paste0("$\\phantom{,}^{",
                str_extract_all(species, "[:digit:]+(?=[:alpha:])")[[1]][1],
                "}$"),
         str_extract_all(species, "[:alpha:]+")[[1]][1],
         paste0("$_{",
                str_extract_all(species, "(?<=[:alpha:])[:digit:]+")[[1]][1],
                "}$")
         ),
  paste0(
         paste0("$\\phantom{,}^{",
                str_extract_all(species, "[:digit:]+(?=[:alpha:])")[[1]][2],
                "}$"),
         str_extract_all(species, "[:alpha:]+")[[1]][2],
         paste0("$_{",
                str_extract_all(species, "(?<=[:alpha:])[:digit:]+")[[1]][2],
                "}$")
         ),
  sep = sep
  )

species <- str_replace_all(species, "NA", "")

}else{

R <- paste(
  paste0(
    paste0("$\\phantom{,}^{",str_extract(ion1, "^\\d+"),"}$"),
    str_extract(ion1, "\\D+"),
    paste0("$_{",str_extract(ion1, "\\d*$"),"}$")
  ),
  paste0(
    paste0("$\\phantom{,}^{",str_extract(ion2, "^\\d+"),"}$"),
    str_extract(ion2, "\\D+"),
    paste0("$_{",str_extract(ion2, "\\d*$"),"}$")
  ), sep = "/")

}

}

des_SD_prop <- function(M_R, ion1, ion2, M_ion1, M_ion2, S_ion1, S_ion2, n,
                        type = "sd"){

  M_R <- unique(M_R)
  n <- unique(n)

  sd <- sqrt(
              ((unique(S_ion1) / unique(M_ion1)) ^ 2) +
              ((unique(S_ion2) / unique(M_ion2)) ^ 2) -
              (2 *
                  (
                    cov(ion1, ion2, method = "pearson", use = "everything") /
                    (unique(M_ion1) * unique(M_ion2))
                  )
              )
            )

  if (type == "sd") {return(sd * M_R)}
  if (type == "rsd") {return(sd * 1000)}
  if (type == "se") {return(sd * M_R / sqrt(n))}
  if (type == "rse") {return((sd / sqrt(n)) * 1000)}
}

hat_SD_prop <- function(M_R, ion1, ion2 ,N_ion1, N_ion2, n, type = "sd"){

  M_R <- unique(M_R)
  n <- unique(n)

  hat_sd <- sqrt(
                  (1 / sum(N_ion1)) +
                  (1 / sum(N_ion2))
                )

  if (type == "sd") {return(hat_sd * M_R * sqrt(n))}
  if (type == "rsd") {return(hat_sd * sqrt(n) * 1000)}
  if (type == "se") {return(hat_sd * M_R / sqrt(n))}
  if (type == "rse") {return((hat_sd / sqrt(n)) * 1000)}
}

sum_sd_prop <- function(x, type = "rse"){

  n <- length(x)
  sum_sd <- sqrt( 1 / sum(x^-2))

}
