#' Analyse raw ion count data
#'
#' \code{stat_Xt} function for propagation of uncertainty for single ions
#' \code{stat_R} function for propagation of uncertainty for isotope ratios (R)
#'
#' Ion count data consisting of time-incremented integer values are process.
#' These functions are currently only supported for data generated by a
#' NanoSIMS50L. Raw ion count data and accompayning is extracted and collated
#' into a single tible from text files with the extensions \emph{.is_txt} and
#' \emph{.stat}, respectively. These files can be found in the directories
#' associated with the SIMS measurements.
#'
#' @param df A tibble containing processed ion count data
#' @param Xt A variable constituting the ion count rate
#' @param N A variable constituting the ion counts
#' @param ... Variables for grouping
#' @param ID A character string that uniqually identifies ion pairs for
#' calculating isotope ratios
#' @param ion1 A character string constituting the heavy isotope ("13C")
#' @param ion2 A character string constituting the light isotope ("12C")
#'
#' @return A tibble containing descriptive and predictive statistics for ion
#' count and isotope ratio data
#'
#' @examples
#' # Use system.file() to access the examples bundled with this package in the
#' # inst/extdata directory. The examples directories are named:
#' # 2020-01-17-TREASURE and "2018-01-19-GLENDON"
#'
#' # raw data containing 13C and 12C counts on carbonate
#' tb.rw <- read_IC(system.file("extdata", "2018-01-19-GLENDON", package = "point"))
#'
#' # processing raw ion count data
#' tb.pr <- cor_IC(tb.rw, N.rw, t.rw, det_type.mt)
#'
#' # single ion descriptive an predictive statistics for all measured ions
#' tb.Xt <- stat_Xt(tb.pr, Xt.pr, N.pr, file.nm, species.nm)
#'
#' # descriptive an predictive statistics for 13C/12C ratios
#' tb.R <- stat_R(tb.pr, Xt.pr, N.pr, ID = "ID", ion1 = "13C", ion2 = "12C",
#'                file.nm, species.nm)
#'
#' @export
stat_Xt <- function(df, Xt, N, species, ... , latex = FALSE){

  Xt <- enquo(Xt)
  N <- enquo(N)
  gr_by <- enquos(..., species)

  args <- list(# number of ion counts
    quo(n()),
    # sum of ion counts (important for external rep)
    quo(sum(!! N)),
    # mean ion count rate
    quo(mean(!! Xt)),
    # standard deviation (SD) count rate
    quo(sd(!! Xt)),
    # standard error of the mean (SE) count rate
    quo(sd(!! Xt) / sqrt(n())),
    # predicted SD count rate
    quo(sqrt(sum(!!N))),
    # predicted SE count rate
    quo(sqrt(sum(!!N) / n())))

  ls.names <-paste0(c("n_", "Ntot_", "M_", "S_", "SeM_", "hat_S_", "hat_SeM_"),
                    quo_name(Xt))

  # to render nice latex variable names in Rmarkdown with mathjax and latex
  ls.latex <- ls.names %>%
    purrr::set_names(., nm = c("$n$",
                               "$N_{tot}$",
                               "$\\bar{X}$",
                               "$s_X$",
                               "$s_\\bar{X}$",
                               "$\\hat{s}_N$",
                               "$\\hat{s}_\\bar{N}$"))

  args <- purrr::set_names(args, nm = ls.names)

  df <- df %>%
    group_by(!!! gr_by) %>%
    summarise(!!! args) %>%
    ungroup()

  if(latex) {

      df <- df %>%
              mutate(species.nm = purrr::map_chr(species.nm,
                                                 ~latex_parser(.x,
                                                               ion1 = NULL,
                                                               ion2 = NULL)))

# return list for nice latex variable names in Rmarkdown with mathjax and latex
    return(list(df, ls.latex))

    } else {

      return(df)
    }

  }


#' function for propagation of uncertainty in ion ratios (isotope values)
#' @export
stat_R <- function(df, Xt, N, species, ion1, ion2, ..., latex = FALSE){

  Xt <- enquo(Xt)
  N <- enquo(N)
  species <- enquo(species)
  gr_by <- enquos(...)


  # # check and remove zero counts
  # df <- zeroCt(df = df, N = !!N, ion1 = ion1, ion2 = ion2, !!! gr_by)

  # heavy isotope
  Xt1 <- quo_updt(Xt, ion1)
  M.Xt1 <- quo_updt(Xt, ion1, "M")
  S.Xt1 <- quo_updt(Xt, ion1, "S")

  # light isotope
  Xt2 <- quo_updt(Xt, ion2)
  M.Xt2 <- quo_updt(Xt, ion2, "M")
  S.Xt2 <- quo_updt(Xt, ion2, "S")

  # heavy raw counts
  Yt1 <- quo_updt(N, ion1)
  # light raw counts
  Yt2 <- quo_updt(N, ion2)

  args <- list(
    # number of isotope
    quo(n()),
    # mean isotope
    quo(mean(!!Xt1) / mean(!!Xt2)),
    # correlation coefficient
    quo(cor(!!Xt1, !!Xt2, method = "pearson")),
    # SD isotope
    quo(sqrt(
      ((unique(!!S.Xt1) / unique(!!M.Xt1)) ^ 2) +
        ((unique(!!S.Xt2) / unique(!!M.Xt2)) ^ 2) -
        ((2 * !!quo_updt(my_q = Xt , x = "cor_R") *
            unique(!!S.Xt1)  *
            unique(!!S.Xt2)) /
           (unique(!!M.Xt1) * unique(!!M.Xt2)))) *
        !!quo_updt(my_q = Xt , x = "M_R")),
    # RSD isotope
    quo((!!quo_updt(my_q = Xt , x = "S_R") /
         !!quo_updt(my_q = Xt , x = "M_R")) * 1000),
    # SE isotope
    quo(!!quo_updt(my_q = Xt , x = "S_R") / sqrt(n())),
    # RSE isotope
    quo((!!quo_updt(my_q = Xt , x = "SeM_R") /
         !!quo_updt(my_q = Xt , x = "M_R")) * 1000),
    # predictive SD isotope
    quo(sqrt((1 / sum(!!Yt2)) +
             (1 / sum(!!Yt1))) *
          unique(!!quo_updt(my_q = Xt , x = "M_R")) *
          sqrt(n())),
    # predictive RSD isotope
    quo((!!quo_updt(my_q = Xt , x = "hat_S_R") /
         !!quo_updt(my_q = Xt , x = "M_R")) * 1000),
    # predictive SE isotope
    quo(sqrt((1 / sum(!!Yt2)) +
             (1 / sum(!!Yt1))) *
        unique(!!quo_updt(my_q = Xt , x = "M_R"))),
    # predictive RSE isotope
    quo(sqrt((1 / sum(!!Yt2)) +
             (1 / sum(!!Yt1))) * 1000),
    # reduced chi squared
    quo((!!quo_updt(my_q = Xt , x = "SeM_R") /
         !!quo_updt(my_q = Xt , x = "hat_SeM_R")) ^ 2)
  )

  ls.names <-paste(c("n", "M", "cor", "S", "RS", "SeM", "RSeM",
                     "hat_S", "hat_RS", "hat_SeM", "hat_RSeM",
                     "chi2"), "R", quo_name(Xt), sep = "_")

# to render nice latex variable names in Rmarkdown with mathjax and latex
  ls.latex <- ls.names %>%
                purrr::set_names(., nm = c("$n$",
                                           "$\\bar{R}$",
                                           "$r$",
                                           "$s_{R}$",
                                           "$\\epsilon_{R} \\, (\\text{‰})$",
                                           "$s_{\\bar{R}}$",
                                           "$\\epsilon_{\\bar{R}} \\, (\\text{‰})$",
                                           "$\\hat{s}_{R}$",
                                           "$\\hat{\\epsilon}_{R} \\, (\\text{‰})$",
                                           "$\\hat{s}_{\\bar{R}}$",
                                           "$\\hat{\\epsilon}_{\\bar{R}} \\, (\\text{‰})$",
                                           "$\\chi^{2}$"))

  args <- purrr::set_names(args, nm = ls.names)

  gr_names <- c(sapply(gr_by, as_name), purrr::pluck(as_name(species)))

  df <- df  %>%
          stat_Xt(., Xt = !!Xt, N = !!N, species =  !!species, !!! gr_by) %>%
          left_join(df, . , by = gr_names) %>%
    # check and remove zero counts
          zeroCt(., N = !!N, species = !!species, ion1 = "13C", ion2 = "12C", !!! gr_by) %>%

          cov_R(df = . , species = !!species, ion1 = ion1, ion2 = ion2, !!! gr_by) %>%
          group_by(!!! gr_by) %>%
          summarise(!!! args) %>%
          ungroup()

# return list for nice latex variable names in Rmarkdown with mathjax and latex
  if (latex) {

    df <- df %>%
      mutate(R.nm = latex_parser(species = NULL, ion1, ion2))

    return(list(df, ls.latex))


    } else {return(df)}
}



#' function to detect and remove zero counts of desired isotope system
zeroCt <- function(df, N, species, ion1, ion2, ...){

  N <- enquo(N)
  species <- enquo(species)
  gr_by <- enquos(...)

  gr.ls <- df %>%
            filter_at(vars(!!species), any_vars(. %in% "12C"))

  if (any(gr.ls %>% select(!!N) %>% pull(!!N) == 0)) {

    warning("zero counts present and removed")

  }

  gr.ls <- gr.ls %>%
              filter(!!N == 0) %>%
              select(!!!gr_by)

  df <- anti_join(df, gr.ls, by = sapply(gr_by, as_name))

}

#' covariate convertion for isotope systems
cov_R <- function(df, species, ion1, ion2, ...){

  gr_by <- enquos(...)
  species <- enquo(species)

  df <- df %>%
          group_by(!!! gr_by, !! species) %>%
          mutate(ID = row_number()) %>%
          ungroup() %>%
# uniqually identifies ion pairs for calculating isotope ratios
          tidyr::unite(col = ID, !!! gr_by, ID, sep = "/", remove = FALSE) # %>%
          # filter_at(vars(contains("species")), any_vars(. %in% c("12C", "13C")))

  # filtering single ion stats minor isotope
  # df.13C <- df %>%
  #             filter_at(vars(contains("species")), any_vars(. %in% ion1))
  df.13C <- df %>% filter(!! species == ion1)

  # filtering single ion stats major isotope
  # df.12C <- df %>%
  #             filter_at(vars(contains("species")), any_vars(. %in% ion2)) %>%
  df.12C <- df %>% filter(!! species == ion2) %>%
                    select(-c(!!! gr_by))

  df.R <- full_join(df.13C,  df.12C, by = "ID",
                    suffix = c(paste0(".", ion1),
                               paste0(".", ion2)))
  }

#' quosure updater
quo_updt <- function(my_q, txt = NULL, x = NULL, sepfun = "_"){
  # get expressions
  old_expr <- get_expr(my_q)
  # modify expression, turn expr in to character string
  if (length(txt) == 0){

     new_chr <-paste(x, expr_text(old_expr), sep = sepfun)

     }else{

       if (length(x) == 0){

          new_chr <- paste(expr_text(old_expr),txt, sep = ".")

          }else{
          new_chr <- paste(paste(x, expr_text(old_expr), sep = sepfun), txt, sep = ".")
               }
           }
  # new expression from character
  new_expr <- parse_expr(new_chr)
  # update old quosure
  set_expr(my_q, new_expr)
}


latex_parser <- function(species, ion1, ion2){

if(length(species) != 0){

# seperator for poly atomic speices
if (any(str_detect(species, "[:blank:]"))){
  sep <- "--"
} else {
  sep <- ""}

species <- paste(
  paste0(
         paste0("$\\phantom{,}^{",
                str_extract_all(species, "[:digit:]+(?=[:alpha:])")[[1]][1],
                "}$"),
         str_extract_all(species, "[:alpha:]+")[[1]][1],
         paste0("$_{",
                str_extract_all(species, "(?<=[:alpha:])[:digit:]+")[[1]][1],
                "}$")
         ),
  paste0(
         paste0("$^{",
                str_extract_all(species, "[:digit:]+(?=[:alpha:])")[[1]][2],
                "}$"),
         str_extract_all(species, "[:alpha:]+")[[1]][2],
         paste0("$_{",
                str_extract_all(species, "(?<=[:alpha:])[:digit:]+")[[1]][2],
                "}$")
         ),
  sep = sep
  )

species <- str_replace_all(species, "NA", "")

}else{

R <- paste(
  paste0(
    paste0("$\\phantom{,}^{",str_extract(ion1, "^\\d+"),"}$"),
    str_extract(ion1, "\\D+"),
    paste0("$_{",str_extract(ion1, "\\d*$"),"}$")
  ),
  paste0(
    paste0("$\\phantom{,}^{",str_extract(ion2, "^\\d+"),"}$"),
    str_extract(ion2, "\\D+"),
    paste0("$_{",str_extract(ion2, "\\d*$"),"}$")
  ), sep = "/")

}

}
