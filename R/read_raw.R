#' Read raw ion count data
#'
#' \code{read_IC()} is designed to obtain the numerical data associated with ion
#' counts.
#' \code{read_meta()} can be used to solely retrieve the metadate associated with ion
#' count data analysis; loading specifications related to optics, the primary
#' and secondary ion beam, and mass spectrometer settings.
#'
#' Ion count data consists of time-incremented integer values. These functions
#' are currently only supported for data generated by a NanoSIMS50L. Raw ion
#' count data and accompayning is extracted and collated into a single tible
#' from text files with the extensions \emph{.is_txt} \emph{.chk_is} and \emph{.stat},
#' respectively. These files can be found in the directories associated with the
#' SIMS measurements.
#'
#' @param directory A path or connection to a directory containing raw ion count
#' data txt  files.
#'
#' @return A \code{\link[tibble:tibble]{tibble}} containing raw ion count data and metadata
#'
#' @examples
#' # Use point_example() to access the examples bundled with this package in the
#' # inst/extdata directory. The examples directories are named:
#' # 2020-01-17-TREASURE and "2018-01-19-GLENDON"
#'
#' read_IC(point_example("2018-01-19-GLENDON"))
#'
#' @export
read_IC <- function(directory){

  l.c <- read_validator(directory)

# collecting metadata (stat file)
  tb.meta <- read_meta(directory)

# include count blocks
  fun_bl<- function(x, y) {

    seq <- rep(1: unique(x), each = unique(y))
    n <- row_number()
    seq[n]

  }

# collecting measurement data and metadata
  tb.rw <- left_join(

# raw count data of measerument
                     purrr::map_df(l.c,
                            ~read_tsv(paste0(directory, "/", .),
                                      col_names = c("t.rw", "N.rw"),
                                      col_types = "-cc",
                                      # col_types = cols(X1 = col_skip(),
                                      #                  t.rw = col_character(),
                                      #                  N.rw = col_character()),
                                      comment = "B",
                                      skip = 1,
# n-max is n times number of species
                                      n_max = with(tb.meta,
                                                   (unique(
                                                     n.rw[file.nm == .]) + 1) *
                                                     length(unique(species.nm)))
                                     ),
                            .id = "file.nm") %>%
# remove old column headers
                                filter(t.rw != "X", N.rw  != "Y") %>%
# coercion to numeric values
                                mutate(t.rw = as.numeric(t.rw),
                                       N.rw = as.numeric(N.rw)) %>%
                                group_by(file.nm) %>%
                                mutate(num.mt =
                                         ntile(n =
                                                 with(tb.meta,
                                                      length(unique(
                                                        species.nm))))) %>%
                                ungroup(),

      tb.meta,

      by = c("file.nm", "num.mt")) %>%
# clear suffix from filename
        mutate(file.nm = str_sub(file.nm,
                                  end = (str_length(file.nm) - 7))) %>%
# add block number
        group_by(file.nm, species.nm) %>%
        mutate(bl = fun_bl(`bl_num.mt`, `meas_bl.mt`)) %>%
# uniqually identifies ion pairs for calculating isotope ratios
        mutate(ID = row_number()) %>%
        ungroup() %>%
        tidyr::unite(col = ID, file.nm, ID, sep = "/", remove = FALSE)

  return(tb.rw)
}


# validation function to check for empty files or files with empty columns
read_validator <- function(directory){

# argument class check
  stopifnot(is.character(directory))

# extract txt files with count data blocks of each single point measurement
  l.c <- dir(directory,
             pattern = ".is_txt") %>%
           purrr::set_names()

# length check of txt files
    if (any(purrr::map_dbl(l.c, ~length(read_lines(paste0(directory, "/", .), n_max = 2)
                           )) == 0)) {

      good <- purrr::map_dbl(l.c, ~length(read_lines(paste0(directory, "/", .), n_max = 2))) > 0

      l.c <- l.c[good]

      warning("empty txt file removed")

    }

# column content check of txt files
      if (any(purrr::map_dbl(l.c, ~
                 nrow(read_tsv(paste0(directory, "/", .),
                               comment = "B",
                               skip = 1,
                               col_names = c("t", "N"),
                               col_types = "-cc",
                               # col_types = cols(X1 = col_skip(),
                               #                  t = col_character(),
                               #                  N = col_character()),
                               n_max = 2) %>%
                                filter(t != "X", N  != "Y"))) == 0)){

         good <- purrr::map_dbl(l.c, ~nrow(read_tsv(paste0(directory, "/", .),
                                             comment = "B",
                                             skip = 1,
                                             col_names = c("X1", "t", "N"),
                                             col_types = cols(X1 = col_skip(),
                                                              t = col_character(),
                                                              N = col_character()),
                                             n_max = 2) %>%
                                               filter(t != "X", N  != "Y"))) > 0

         l.c <- l.c[good]

         warning("txt file contains empty columns")

       }

  return(l.c)

}


#' @rdname read_IC
#'
#' @export
read_meta <- function(directory){

# NA aliases
  NA_aliases <- c("N/A", "none", "None") %>%
                  purrr::set_names(rep(NA_character_,
                                       length(.)), nm = .)

# extract stat files with diagnostics of the machine and statistics
  l.s <- dir(directory,
             pattern = ".stat$") %>%
# set names for subsequent storage
           purrr::set_names() %>%
# remove transect files
           purrr::discard(., str_detect(., "transect.stat"))

  l.p <- dir(directory,
             pattern = ".chk_is$") %>%
# set names for subsequent storage
           purrr::set_names() %>%
# remove transect files
           purrr::discard(., str_detect(., "transect.chk_is"))

  PHD_n <- lapply(purrr::map(l.p, ~read_lines(paste0(directory, "/", .),
                                       n_max = 50) ),
                  str_which, "PHDc(?=\\(Mass)")

  l.PHD <- lst(a = l.p,  b = PHD_n, c = lapply(b, length))

  f.PHD <- function(a, b, c) {

         readr::read_table2(paste0(directory, "/", a),

                            col_names = c("num.mt", "mean_PHD", "SD_PHD", "EMHV"),
                            col_types = "-cddd",
                            na = c(mapply(strrep,"X", 1:10, USE.NAMES =  FALSE), "1.#R"),
                            skip = b[1] - 1,
                            n_max = c)
  }

  tb.PHD <- purrr::pmap_dfr(l.PHD, f.PHD, .id = "file.nm") %>%
                  mutate(file.nm = str_sub(file.nm,
                             end = (str_length(file.nm) - 7))) %>%
                  mutate(num.mt = as.numeric(str_extract(num.mt,"[:digit:]")))


  min_n <- lapply(purrr::map(l.s, ~read_lines(paste0(directory, "/", .),
                                       n_max = 50)),
                  str_which, "#") %>%
            purrr::map(., 1) %>%
            purrr::flatten_dbl()

  max_n <- lapply(purrr::map(l.s, ~read_lines(paste0(directory, "/", .),
                                       n_max = 50)),
                  str_which, "--") %>%
            purrr::map(., 1) %>%
            purrr::flatten_dbl()

# ions and MS setup
  l <- lst(a = l.s, b =  min_n  , c = (max_n - 3) - b )
  f <- function(a, b, c) {

        read_table(paste0(directory, "/", a),
                   skip = b,
                   n_max = c,
                   col_names = c("num.mt", "species.nm", "mass.mt", "det.mt",
                                 "tc.mt (s)", "bfield.mt", "rad.mt"),
                   col_types = "icdcddd---",
                   #   cols(
                   #                  num.mt = col_integer(),
                   #                  species.nm = col_character(),
                   #                  mass.mt = col_double(),
                   #                  det.mt = col_character(),
                   #                  `tc.mt (s)` = col_double(),
                   #                  bfield.mt = col_double(),
                   #                  rad.mt = col_double(),
                   #                  X2  = col_skip(),
                   #                  X3 = col_skip(),
                   #                  X4 = col_skip()
                   # )
                   )

  }


  tb.ion <- purrr::pmap_dfr(l, f, .id = "file.nm") %>%
              mutate(file.nm = str_sub(file.nm,
                                       end = (str_length(file.nm) - 5)))

# primary and secondary ion beam metadata

  tb.meas <- purrr::map2_df(l.s, min_n - 1 , ~(read_lines(paste0(directory, "/", .x),
                                        n_max = .y)) %>%
                            list() %>%
                              tibble::enframe(name = NULL),
                   .id = "file.nm") %>%
              mutate(file.nm = str_sub(file.nm,
                                       end = (str_length(file.nm) - 5)))

# function to make metadate readible
  str_unfold <-  function(string) {

    string %>%
# create tibble from list
      tibble::enframe(name = NULL) %>%
# remove empty rows
      filter(str_detect(value, ".")) %>%
# remove date
      filter(!str_detect(value, pattern  = "\t\t\t\t\t\t")) %>%
      tidyr::separate_rows(value, sep = "(/(?=[:blank:])) | =") %>%
      tidyr::separate(value,
               into = c("variable", "value"),
               sep =":(?!\\\\)",
               extra = "merge") %>%
      mutate_all(str_trim) %>%
      distinct(., variable, .keep_all = TRUE) %>%
# convert NA aliases to NA
      mutate(value = recode(value, !!!NA_aliases),
# remove units behind numerics
             value = str_replace(value, "(?<=[:digit:]|[:blank:])(pA|um|%)|Det1=", "")) %>%
      tidyr::pivot_wider(names_from = variable, values_from = value) %>%
# separate date
      mutate(date = as.POSIXct(
        str_replace_all(
                                        string[str_detect(string,
                                               pattern  = "\t\t\t\t\t\t")],
                                        "\\t|\\n", ""),
                       format = c("%d.%m.%y  %H:%M")
                       )) %>%
      rename(sample.nm = "CAMECA \\ ISOTOPES \\ Sample") %>%
# remove extra dot
      mutate(`Pre Sputtering Time (s)` = str_sub(`Pre Sputtering Time (s)`, end = -2))

  }


meta.nm  <- c(
              `presput.mt` = "Pre Sputtering Time (s)",
              `bl_num.mt` = "Block number",
              `meas_bl.mt` = "Meas. per block",
              `width_hor.mt` = "Width Horizontal(V)",
              `width_ver.mt` =  "Vertical(V)",
              `prim_cur_start.mt` = "Primary Current before acq",
              `prim_cur_after.mt` = "after acq",
              `rast_com.mt` = "Raster (um)",
              `blank_rast.mt` = "Blanking",
              `FC_start.mt` = "FC Background before acq",
              `FC_after.mt` = "FC Background after acq"
              )

  tb.meas <- tb.meas %>%
               mutate(value = purrr::map(value, str_unfold)) %>%
               tidyr::unnest(cols = c(value)) %>%
               select(file.nm, sample.nm, date, !!! meta.nm[meta.nm %in% colnames(.)]) %>%
               mutate_at(vars(contains(".mt")), as.double) %>%
# add measurement number
               mutate(n.rw = `bl_num.mt` * `meas_bl.mt`) %>%
# add electron detector type (EM or FC)
               mutate(det_type.mt = if_else("FC_start.mt" %in% colnames(.),
                                            "FC", "EM"))

# combine PHD, MS and beam metadata
  tb.meta <- list(tb.ion, tb.meas, tb.PHD) %>%
               purrr::reduce2(., lst(by = c("file.nm"),
                                     by = c("file.nm", "num.mt")) , left_join) %>%
               mutate(file.nm = paste0(file.nm, ".is_txt"))

  return(tb.meta)
  }


# function to read CAMECA output to validate point output
# read_test
read_test <- function(directory, block = 1){

  # block for checking
  if (block == 1) {bl <- 2}
  if (block == 4) {bl <- max}

  # extract stat files with diagnostics of the machine and statistics
  l.s <- dir(directory,
             pattern = ".stat$") %>%
    # set names for subsequent storage
    purrr::set_names() %>%
    # remove transect files
    purrr::discard(., str_detect(., "transect.stat"))


  max_n <- lapply(purrr::map(l.s, ~read_lines(paste0(directory, "/", .),
                                                n_max = -1)),
                    str_which, "Mass#") %>%
    purrr::map(., bl) %>%
    purrr::flatten_dbl()


# test dataset
  l.R <- lst(a = l.s, b =  max_n  + 10 , c = 5) # isotope
  l.N <- lst(a = l.s, b =  max_n, c = 7) # cumulative count
# function
  fun_read.R <- function(a, b, c) {

    read_table(paste0(directory, "/", a),
               skip =  b,
               n_max = c,
               col_names = c("R.nm", "M_R_Xt.test",
                             "hat_RSeM_R_Xt.test", "RSeM_R_Xt.test",
                             "chi2_R_Xt.test"),
               col_types = "cdddd-") %>%
      mutate(RSeM_R_Xt.test = RSeM_R_Xt.test * 10,
             hat_RSeM_R_Xt.test = hat_RSeM_R_Xt.test *10)
  }

  fun_read.N <- function(a, b, c) {

    read_table(paste0(directory, "/", a),
                       skip = b,
                       n_max = c ,
                       col_names = c("num.mt", "Ntot_Xt.test"),
                       col_types = "cd") %>%
      tidyr::drop_na()
  }

  tb.test.R <- purrr::pmap_dfr(l.R, fun_read.R, .id = "file.nm") %>%
                 mutate(file.nm = str_sub(file.nm,
                                        end = (str_length(file.nm) - 5))) #%>%
                 # mutate(file.nm = paste0(file.nm, ".is_txt"))

  tb.test.N <- purrr::pmap_dfr(l.N, fun_read.N, .id = "file.nm") %>%
                 mutate(file.nm = str_sub(file.nm,
                                          end = (str_length(file.nm) - 5))) #%>%
                 # mutate(file.nm = paste0(file.nm, ".is_txt"))

  return(list(tb.test.N = tb.test.N, tb.test.R = tb.test.R))
}




#' Get path to point example
#'
#' This function comes from the package `readr`, and has been modified to access
#' the bundled datatsets in it directory `inst/extdata` of `point`. This
#' function make them easy to access
#'
#' @param path Name of file. If `NULL`, the example files will be listed.
#' @export
#' @examples
#' point_example()
#' point_example("2018-01-19-GLENDON")
point_example <- function(path = NULL) {
  if (is.null(path)) {
    dir(system.file("extdata", package = "point"))
  } else {
    system.file("extdata", path, package = "point", mustWork = TRUE)
  }
}
