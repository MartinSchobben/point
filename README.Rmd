---
output: 
  github_document:
    pandoc_args: --webtex
---
<!--  use the --webtex argument in the YAML to render equations -->


```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%",
  warning = FALSE, 
  results = "asis",
  encoding ='UTF-8'
)
```

# Introduction to point

<!-- badges: start -->
<!-- badges: end -->

This projects was originally inspired by the lack of detailed insight in the inner workings of the default software for the Cameca NanoSIMS50L (Utrecht University). Hence this project has the objective of processing raw count data into ion and isotope ratios of point-sourced measurements, and to establish the internal and external precision of individual measurements and complete series of measurements, respectively. Access to raw ion count data is useful as it allows detection of anomolous values associated with e.g. machine instability or heterogeneity of the analysed sample. Such anomolous values can then be omitted, or further analysed to delineate the source of variation.

## Installation

You can install the released version of point 

<!-- ``` r -->
<!-- install.packages("point") -->
<!-- ``` -->

## Example1: internal precision of isotope ratios

This is an example of how Cameca NanoSIMS50L raw datafiles can be extracted, processed and analysed for the ^13^C/^12^C isotope ratio (R). This produces a tibble with descriptive and predictive poisson statistics (demarcated with an $\\\hat{}$) of the ion count data. This can be done for single count blocks in order to obtain internal precision.

```{r example}

# library(point)
devtools::load_all(".")

# Use point_example() to access the examples bundled with this package in the
# inst/extdata directory. The examples directories are named:
# 2020-01-17-TREASURE and "2018-01-19-GLENDON"

# raw data containing 13C and 12C counts on carbonate
tb.rw <- read_IC(point_example("2018-01-19-GLENDON"))

# processing raw ion count data
tb.pr <- cor_IC(tb.rw, N.rw, t.rw, det_type.mt, deadtime = 44, thr = 180)

# single ion descriptive an predictive statistics for all measured ions
tb.Xt <- stat_Xt(tb.pr, Xt.pr, N.pr, species.nm, sample.nm, file.nm)

# descriptive an predictive statistics for 13C/12C ratios
tb.R <- stat_R(tb.pr, Xt.pr, N.pr, species.nm, ion1 = "13C", ion2 = "12C", 
               sample.nm, file.nm, latex = TRUE)


# use the second element of the list to get nice variable names rendering in 
# Rmarkdown
knitr::kable(head(tb.R[[1]] %>% 
                    rename(sample = "sample.nm", file = "file.nm", R = "R.nm", 
                                   !!! tb.R[[2]])),
             format.args = list(digits = 5, format = "G", flag = "0")) 
```


## Example 2: external precision of isotope ratios

To calculate the external reproducibility of isotope ratios one needs to use the total ion count of one block and the block count rate. The latter is equivalent to the mean ion count rate, which was already calculated with the function `stat_Xt`. 

```{r}
# For this particular run a belemnite was used as reference material. 
tb.R.ext  <- stat_R(tb.Xt, 
                    Xt = M_Xt.pr, 
                    N = Ntot_Xt.pr, 
                    species = species.nm, 
                    ion1 = "13C", 
                    ion2 = "12C",  
                    sample.nm, 
                    latex = TRUE)

knitr::kable(head(tb.R.ext[[1]]  %>% 
                    filter(str_detect(sample.nm, "Belemnite")) %>% 
                    rename(sample = "sample.nm", R = "R.nm", 
                                   !!! tb.R.ext[[2]])),
              format.args = list(digits = 5, format = "G", flag = "0")) 

```

For more detailed information about reading raw ion count data use `vignette("IC-read")`; processing ion count data `vignette("IC-read")`; and for statistical test concerning ion count precision `vignette("IC-precision")`.
