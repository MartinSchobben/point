---
title: "IC-read"
author: "Martin Schobben" 
output: 
  rmarkdown::html_vignette:
    fig_caption: true
    pandoc_args:  [
      "--csl", "~/Documents/work/projects/Glendonite_project/common/aquatic-microbial-ecology.csl",
      "--citation-abbreviations", "~/Documents/work/projects/Glendonite_project/common/abbreviations.json", "--filter", "~/.cabal/bin/pandoc-crossref"
               ]
    ccs: /home/nicola/Documents/work/projects/Code/point/vignettes/custom.ccs
bibliography: SIMS.bib
vignette: >
  %\VignetteIndexEntry{IC-read}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)

# cross referencing figures in HTML
library(kfigr)
```


# Reading Raw Ion Count Data and Metadata

The read functions are currently only supported for data generated by a NanoSIMS50L. Raw ion count data and accompayning metadata is extracted and collated into a single tible from text files with the extensions *.is_txt*, *.chk_is* and *.stat*, respectively. These files can usually be found in a single directory often constituting the analysis on a series of spots.

## Nomenclature

* Sample: sample of the true population
* Analytical substrate: Physical sample measured during SIMS analysis
* Event: single event of an ion hitting the detector
* Measurement: single count cycle $N_i$
* Count block: multitude of measurements $N_{(i)}$ (count cycles of length $n$)
* Analysis: multitude of count blocks, constituting the different spots on the analytical substrate 

```{r setup}
library(point)
devtools::load_all(".")
```

## Example dataset
Two example datasets are bundled with this package:

* 2018-01-19-GLENDON
* 2020-01-17-TREASURE 

Both datasets are generated with the *Cameca NanoSIMS 50L* at the Department of Earth Sciences at Utrecht University. The dataset with the suffix *GLENDON* contains ion count data on calcium carbonate rock (so-called glendonites) of Jurassic and Cretaceous age. The sampled substrate is a glendonite specimen (an authigenic carbonate) and a in-house reference (a belemnite rostra). Ion detection for 7 individual species was performed solely with electron multipliers (EM) with the main purpose of producing stabel carbon isotope ratios (^13^C/^12^C). The dataset with the suffix *TREASURE* consists of ion count data on pyrite minerals collected in the Baltic Sea. These analysis targetted the ^34^S/^32^S composition, where the heavy isotope was collected on an EM and the ligth isotope on a Faraday Cup (FC).

The example directories can be accessed with the function `point_example`.

```{r}
point_example("2018-01-19-GLENDON")
```


## Extracting raw ion count data and associated metadata

The function `read_IC` takes a single argument, which is a character string indicating the directory file name. 

```{r}
read_IC(point_example("2018-01-19-GLENDON"))
```


This generates a tibble which includes;

* `N.rw`: the individual measurement counts $N_i$
* `t.w`: time increments of the measurements $t_i$
* `file.nm`: file name
* `ID`: unique identifier which links chemical species of a single count block

The data is complemented with metadata of the associated measurement; 

* `num.mt`: measurement order in case of multiple chemical species
* `species.nm`: chemical species name
* `mass.mt`: mass measured
* `det.mt`: number of the detector trolley
* `tc.mt`: cumulate measurement time of a block in seconds
* `rad.mt`: radius of the mass spectrometer
* `sample.nm`: the assigned sample name
* `data`: date of the analysis
* `presput.mt`: time allocated for presputtering of the analyical substrate in seconds
* `bl_num.mt`: block number
* `meas_bl.mt`: number of measurements per block
* `width_hor.mt`: horizontal Secondary Ion Beam Centering in Volts
* `width_ver.mt`: vertical Secondary Ion Beam Centering in Volts
* `prim_cur_start.mt`: Primary Ion Beam current in pico Ampere at the beginning of the analysis
* `prim_cur_after.mt`: Primary Ion Beam current in pico Ampere at the end of the analysis
* `rast_com.mt`: raster dimensions in micrometer
* `blank_rast.mt`: percentage of blanked raster
* `n.rw`: the total number of measurements $n$
* `det_type.mt`: the type of ion counting devise; Electron Multiplier (EM) or Faraday Cup (FC) 

In the case of EM usage for ion counting the metadate is complemented with;

* `mean_PHD`: the mean pulse height amplitude in Volts to approximate the peak height distribution (PHD)
* `SD_PHD`: the standard deviation of pulse height amplitude in Volts to approximate the PHD 
* `EMHV`: EM High Voltage  

In the case of FC usage for ion counting the metadate is complemented with;

* `FC_start.mt`: FC background count before data acquisition
* `FC_after.mt`: FC background count after data acquisition


## Extracting metadata for machine performance assessment

Alternatively one can also only extract the metadata information to assess the machine performance. For example, one can assess the Peak Hight Distribtuion (PHD) over a series of analysis.  

```{r FigPHD, ref.label = "FigPHD", anchor = "figure", fig.width=6, fig.height=6, fig.cap="The PHD with normalised units on the Y-axis approximated with the Polya-Aeppli density probability function with parameter lambda and prob for the location and shape of the curve. These parameters can be calculated using the metadata variables mean_PHD (mean) and SD_PHD (variance)."}

tb.mt <- read_meta(point_example("2018-01-19-GLENDON"))

# The polya density distribution model to approximate PHD distributions
# install.packages("polyaAeppli")

tb.mt <- tb.mt %>% 
           tidyr::drop_na(mean_PHD, SD_PHD) %>% 
           filter(species.nm == "12C") %>%  # most high intensity counts
           mutate(PHD = purrr::map(mean_PHD, ~as.integer(seq(0, 700, length = 100)))) %>%
           tidyr::unnest(cols = c(PHD)) %>% 
           mutate(lambda = (2 * mean_PHD^2) / (SD_PHD^2 + mean_PHD),
                  prob = (SD_PHD^2 - mean_PHD) / (SD_PHD^2 + mean_PHD),
                  prob = if_else(prob < 0 | prob >= 1 , NA_real_, prob),
                  ) %>% 
           tidyr::drop_na(lambda, prob) %>% 
           mutate(density = polyaAeppli::dPolyaAeppli(PHD, lambda = lambda, prob = prob),
                  Y = polyaAeppli::pPolyaAeppli(50, lambda = lambda, prob = prob, lower.tail = FALSE)) %>% 
           group_by(file.nm) %>% 
           mutate(Yy = max(density) * 0.8) %>% 
           ungroup()

ggplot(tb.mt, aes(x = PHD, y = density)) +
  geom_line() +
  geom_text(aes(x = 500, y = Yy, label = paste("Y = ", round(Y, 2)))) +
  facet_wrap(vars(date), scales = "free") +
  theme_classic()

```

The compounded Polya-Aeppli density probability function can approximate the peak height distribution  [@Dietz1970; @Dietz1978]. The package `pPolyaAeppli` [@Burden2014] together with the discriminator threshold value (usually 50 V) enables calculating the EM Yield ($Y$) (Fig. `r figr("FigPHD")`). More on this topic can be found in the vignette *IC-process*.

# References
