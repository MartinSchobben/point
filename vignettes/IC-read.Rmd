---
title: "IC-read"
author: "Martin Schobben" 
package: "point"
output: 
  BiocStyle::html_document:
bibliography: SIMS.bib
vignette: >
  %\VignetteIndexEntry{IC-read}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```


# Reading Raw Ion Count Data

The read functions are currently only supported for data generated by a *Cameca NanoSIMS 50L*. Raw ion count data and accompanying metadata is extracted and collated into a single [tibble](https://cran.r-project.org/web/packages/tibble/vignettes/tibble.html) from text files with the extensions *.is_txt*, *.chk_is* and *.stat*, respectively. These files can usually be found in a single directory, which often constitute the analysis on a series of spots.

## Nomenclature

* Sample: sample of the true population
* Analytical substrate: Physical sample measured during SIMS analysis
* Event: single event of an ion hitting the detector
* Measurement: single count cycle $N_i$
* Analysis: $n$-series of measurements $N_{(i)} = M_j$ 
* Study: $m$-series of analyses $M_{(j)}$, constituting the different spots on the analytical substrate   

```{r setup}
library(point) # load package
```

The following packages are used in the examples that follow.

```{r additional_packages, message = FALSE}
library(dplyr) # manipulating data
library(ggplot2) # manipulating strings
library(polyaAeppli) # Polya-Aeppli distribution
library(purrr) # functional programming
library(tidyr) # tidyr data
```

## Example dataset
Two example datasets are bundled with this package:

* 2018-01-19-GLENDON
* 2020-01-17-TREASURE 

Both datasets are generated with the *Cameca NanoSIMS 50L* at the Department of Earth Sciences at Utrecht University. The dataset with the suffix *GLENDON* contains ion count data on calcium carbonate rock (so-called glendonites) of Jurassic and Cretaceous age. The sampled substrate is a glendonite specimen (an authigenic carbonate) and a in-house reference (a belemnite rostra). Ion detection for 7 individual species was performed solely with electron multipliers (EM) with the main purpose of producing stable carbon isotope ratios (^13^C/^12^C). The dataset with the suffix *TREASURE* consists of ion count data on pyrite minerals collected in the Baltic Sea. These analysis targeted the ^34^S/^32^S composition, where the heavy isotope was collected on an EM and the light isotope on a Faraday Cup (FC).

The example directories can be accessed with the function `point_example`.

```{r}
# Use point_example() to access the examples bundled with this package 

# If path is 'NULL', the example directories will be listed
point_example()
# Accessing the example directory 2018-01-19-GLENDON
point_example("2018-01-19-GLENDON")
```


## Extracting raw ion count data and associated metadata

The function `read_IC` takes a single argument, which is a character string indicating the directory file name. 

```{r}
read_IC(point_example("2018-01-19-GLENDON"))
```


This generates a tibble which includes;

* `N.rw`: the individual measurement counts $N_i$
* `t.rw`: time increments of the measurements $t_i$
* `file.nm`: file name
* `ID`: unique identifier which links chemical species of a single analysis
* `bl.mt`: count block identifier

The data is complemented with metadata of the associated analysis; 

* `num.mt`: measurement order in case of multiple chemical species
* `species.nm`: chemical species name
* `mass.mt`: mass measured
* `det.mt`: number of the detector trolley
* `tc.mt`: measurement time of a measurement blanked in seconds
* `rad.mt`: radius of the mass spectrometer
* `sample.nm`: the assigned sample name
* `data`: date of the analysis
* `presput.mt`: time allocated for presputtering of the analytical substrate in seconds
* `bl_num.mt`: block number
* `meas_bl.mt`: number of measurements per block
* `width_hor.mt`: horizontal Secondary Ion Beam Centering in Volts
* `width_ver.mt`: vertical Secondary Ion Beam Centering in Volts
* `prim_cur_start.mt`: Primary Ion Beam current in pico Ampere at the beginning of the analysis
* `prim_cur_after.mt`: Primary Ion Beam current in pico Ampere at the end of the analysis
* `rast_com.mt`: raster dimensions in micrometer
* `blank_rast.mt`: percentage of blanked raster
* `n.rw`: the total number of measurements $n$
* `det_type.mt`: the type of ion counting devise; Electron Multiplier (EM) or Faraday Cup (FC) 

In the case of EM usage for ion counting the metadate is complemented with;

* `mean_PHD`: the mean pulse height amplitude in Volts to approximate the peak height distribution (PHD)
* `SD_PHD`: the standard deviation of pulse height amplitude in Volts to approximate the PHD 
* `EMHV`: EM High Voltage  

In the case of FC usage for ion counting the metadate is complemented with;

* `FC_start.mt`: FC background count before data acquisition
* `FC_after.mt`: FC background count after data acquisition


## Extracting metadata for machine performance assessment

Alternatively, one can also only extract the metadata of an analysis to, e.g., assess machine performance over a sequence of analyses. For example, one can assess the Peak Height Distribution (PHD) over a series of analyses.  

```{r PHDexample, fig.width=6, fig.height=6, fig.cap="The PHD with normalised units on the Y-axis approximated with the Polya-Aeppli density probability function with parameter $\\lambda$ and $p$ for the location and shape of the curve. These parameters can be calculated using the metadata variables mean_PHD (mean) and SD_PHD (variance), which are compiled by the read_meta function."}

tb.mt <- read_meta(point_example("2018-01-19-GLENDON"))

# The polya density distribution model to approximate PHD distributions
# install.packages("polyaAeppli")

tb.mt <- tb.mt %>% 
           drop_na(mean_PHD, SD_PHD) %>% 
           filter(species.nm == "12C") %>%  # most high intensity counts
           mutate(PHD = map(mean_PHD, 
                                   ~as.integer(seq(0, 700, length = 100)))) %>%
           unnest(cols = c(PHD)) %>% 
           mutate(lambda = (2 * mean_PHD^2) / (SD_PHD^2 + mean_PHD),
                  prob = (SD_PHD^2 - mean_PHD) / (SD_PHD^2 + mean_PHD),
                  prob = if_else(prob < 0 | prob >= 1 , NA_real_, prob),
                  ) %>% 
           drop_na(lambda, prob) %>% 
           mutate(density = dPolyaAeppli(PHD, 
                                         lambda = lambda, 
                                         prob = prob),
                  Y = pPolyaAeppli(50, 
                                  lambda = lambda, 
                                  prob = prob, 
                                  lower.tail = FALSE)) %>% 
           group_by(file.nm) %>% 
           mutate(Yy = max(density) * 0.8) %>% 
           ungroup()

# Plot of PHD over analysis sequence
ggplot(tb.mt, aes(x = PHD, y = density)) +
  geom_line() +
  geom_text(aes(x = 500, y = Yy, label = paste("Y = ", round(Y, 2)))) +
  facet_wrap(vars(date), scales = "free") +
  theme_classic()
```

The compounded Polya-Aeppli density probability function can approximate the peak height distribution  [@Dietz1970; @Dietz1978]. The package `pPolyaAeppli` [@Burden2014] together with the discriminator threshold value (usually 50 V) enables calculating the EM Yield ($Y$) (Fig. \@ref(fig:PHDexample)). More on this topic can be found in the vignette [IC-process](IC-process.html).

# References
